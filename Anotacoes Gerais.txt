========================================================================== AULA 06 - C# E .NET ==========================================================================

C# - linguagem;
.Net - plataforma que roda outras linguagens;

.Net:
- CLR (Common Language Runtime) - Máquina virtual, similar a JVM do JAVA. A CLR possui Garbage Collection (objetos não utilizados são automaticamente deslocados da memória);
- é uma documentação que possui suas implementações:
  .Net Framework (2002) - roda somente em sistemas Windows, desktop ou web (roda sobre o IIS);
  Mono (2004) - execução multiplataforma (ex.: Unity);
  Xamarin (2011) - baseado no Mono, para a criação de aplicativos para dispositivos móveis;
  .Net Core (2016) - roda em multiplataformas, muita performance e praticidade;

================================================================== AULA 07 - COMPILAÇÃO E INTERPRETAÇÃO ==================================================================

Linguagem compilada (C, C++)
Linguagem interpretada (PHP, JavaScript)
Linguagem pré-compilada + máquina virtual (Java, C#)

Compilação - necessita de um compilador específico para a plataforma desejada. Talvez haja necessidade de adaptações.
Interpretação - necessita de um programa que irá interpretar o código e convertendo para a plataforma desejada. A vantagem é que o código será escrito uma única vez, porém, a desvantagem é que é um processo mais lento do que a compilação.
Na pré-compilação, é escrito o código-fonte e será feita uma pré-compilação gerando um código intermediário, o bytecode, que será executado em cima da máquina virtual específica de cada sistema. A vantagem é que o bytecode já passou pelo processo de compilação.

==================================================================== AULA 08 - ESTRUTURA APLICAÇÃO C# ====================================================================

Aplicação, na orientação a objetos, é composta por classes.
As classes podem ser agrupadas em namespaces (agrupamento LÓGICO de classes relacionadas):
- Entities (Entidades de negócio, ex.: produto, cliente, pedido)
- Services (serviços do sistema)
- Repositories (classes que acessam os dados)

Assembly (DLL ou EXE) - Agrupamento físico de classes relacionadas (build). Ex.: um sistema muito grande, que possui diversos módulos, podem ser agrupados:
- Módulo Financeiro (entities, services, repositories)
- Módulo Gráficos (Gráficos 3D, Gráficos 2D, Utilitários)
como se fossem subprogramas que formam um programa.

Aplicação ou solução - agrupamento de assemblies relacionados:
Aplicação = Solution
Assembly = Project
Ex.: Sistema de Comércio Eletrônico, pode possuir vários assemblies

============================================================== AULA 09 - INSTALAÇÃO VISUAL STUDIO COMMUNITY ==============================================================

- Documentação:
https://docs.microsoft.com/pt-br/visualstudio/install/install-visual-studio?view=vs-2019

- Download do 'bootstrapper' do Visual Studio:
https://visualstudio.microsoft.com/downloads

Cargas de Trabalho:
- ASP.NET e desenvolvimento Web;
- Desenvolvimento para Azure;
- Desenvolvimento para desktop com .NET;
- Desenvolvimento com a plataforma universal do Windows;
- Processamento e armazenamento de dados;
- Desenvolvimento multiplataforma com .NET Core;

==================================================================== AULA 10 - MEU PRIMEIRO PROGRAMA =====================================================================

-Indentação automática: Ctrl + K + D
-Rodar o projeto: Ctrl + F5
-Aumentar/Diminuir Fonte: Ctrl + Mouse Scroll

============================================================== AULA 11 - ESTRUTURA BÁSICA DE UM PROGRAMA C# ==============================================================

-Estrutura do projeto:
O projeto C# é uma solução. Ele possui um arquivo com extensão .sln (responsável por abrir o projeto).
Arquivo com extensão .csproj é um arquivo de configuração do projeto e somente será alterado, caso deva acrescentar alguma dependência, por exemplo.
As pastas 'bin' e 'obj' são arquivos gerados da compilação do projeto.

-Estrtura do código:
'using...' - referência a algum namespace;
'namespace' - agrupamento de classes relacionadas. É opcional;
'class' - todo código feito, deve estar dentro de uma classe que é a unidade básica da Programação Orientada a Objetos.
'static void Main' - declaração padrão que identifica o entrypoint da aplicação, ou seja, o ponto de entrada.

=================================================================== AULA 12 - DICAS DO VISUAL STUDIO =====================================================================

-Alterar Idioma:
Ferramentas -> Opções -> Ambiente -> Configurações Internacionais -> Idioma
Tools -> Options -> Enviromment -> International Settings -> Language

-Abrir ou fechar o projeto:
Abrir arquivo .sln

-Indentação automática:
Ctrl + K + D

- Quebra de linha nas chaves:
Tools -> Options -> Text Editor -> C# -> Code Estiling -> Formatting -> New Lines

============================================================ AULA 15 - TIPOS BÁSICOS DE DADOS EM C# (PARTE 1) =============================================================

-Link oficial dos tipos de dados (Microsoft):
https://docs.microsfoft.com/en-us/dotnet/csharp/language-reference/keywords/built-in-types-table
 _________________________________________________________________________________________________________________
| C# Types | .Net Framework Type | Signed | Bytes |                        Possible Values                        |
|  sbyte   |    System.SByte     |   Yes  |   1   |                          -128 to 127                          | --|
|  short   |    System.Int16     |   Yes  |   2   |                        -32768 to 32767                        |   |
|   int    |    System.Int32     |   Yes  |   4   |                        -2³¹ to 2³¹ - 1                        |   |
|   long   |    System.Int64     |   Yes  |   8   |                        -2⁶³ to 2⁶³ - 1                        |   |--- Todos para números inteiros. A diferença é
|   byte   |    System.Byte      |   No   |   1   |                            0 to 255                           |   |    se tem sinal ou não e o número de bytes.
|  ushort  |    System.Uint16    |   No   |   2   |                           0 to 65535                          |   |
|   uint   |    System.Uint32    |   No   |   4   |                          0 to 2³² - 1                         |   |
|   ulong  |    System.Uint64    |   No   |   8   |                          0 to 2⁶⁴ - 1                         | --|
|   float  |    System.Single    |   Yes  |   4   |      ±1.5 x 10-⁴⁵ to± 3.4x10³⁸ with 7 significant figures     |
|  double  |    System.Double    |   Yes  |   8   | ±5.0 x 10-³²⁴ to± 1.7x10³°⁸ with 15 or 16 significant figures |
| decimal  |   System.Decimal    |   Yes  |   12  |  ±1.0 x 10-²⁸ to± 7.9x10²⁸ with 28 or 29 significant figures  |
|   char   |    System.Char      |   N/A  |   2   |                     Any Unicode Character                     |
|   bool   |   System.Boolean    |   N/A  |   12  |                           true or false                       |
 -----------------------------------------------------------------------------------------------------------------

Na declaração de variáveis, usar:
sbyte x = 100;
ou
SByte x = 100;
É a mesma declaração, porém no segundo caso, precisa da referência ('using System') pois a segunda declaração pertence ao namespace System.

-Overflow:
É quando um cálculo extrapola o limite da variável.

-Tipo LONG:
Ao trabalhar com números do tipo long, usa-se a letra L ao final do número para indicar que está trabalhando com número long.

============================================================ AULA 16 - TIPOS BÁSICOS DE DADOS EM C# (PARTE 2) =============================================================

-Utilizar o tipo CHAR:
usa-se aspas SIMPLES;

- Utilizar o código Unicode em uma variável do tipo Char:
Ex: letra A -> Código: 0041
'\u0041'

-Utilizar o tipo FLOAT:
usa-se a letra 'f' ao final do número. Caso não seja utilizado a letra 'f', o sistema irá entender que se trata de um número do tipo DOUBLE;

-Utilizar o tipo STRING:
usa-se aspas DUPLAS;
Strings não são considerados tipos básicos em C#;
 _________________________________________________________________________________________________________________
| C# Types | .Net Framework Type |                                    Descrição                                   |
|  string  |    System.String    | Uma cadeia de caracteres Unicode IMUTÁVEL(segurança, simplicidade, thread safe)|
|  object  |    System.Object    |          Um objeto genérico (toda classe em C# é subclasse de object)          |
|          |                     | GetType, Equals, GetHashCode, ToString                                         |
 -----------------------------------------------------------------------------------------------------------------

-Valores Mínimos e Máximos de um tipo:
Há uma propriedade em cada tipo que informa os valores mínimo e máximo - MinValue e MaxValue:
Ex.: int.MinValue, sbyteMaxValue

============================================================== AULA 17 - RESTRIÇÕES PARA NOMES DE VARIÁVEIS ==============================================================

RESTRIÇÕES:
*Não pode começar com dígito: use uma letra ou _
*Não usar acentos ou til (a linguagem até aceita, mas não é recomendável)
*Não pode ter espaço em branco
*SUGESTÃO: use nomes que tenham significado

ERRADO: 				CORRETO:
int 5minutos;				int _5minutos;
int salário;				int salario;
int salario do funcionario;		int salarioDoFuncionario;

CONVENÇÕES:
*Camel Case: lastName(parâmetros de métodos, variáveis dentro de métodos). Primeira letra minúscula e as demais iniciais maiúsculas;
*Pascal Case: LastName(namespaces, classe, properties e métodos). Todas as iniciais são maiúsculas;
*Padrão -lastname(atributos "internos" da classe)

===================================================================== AULA 18 - SAÍDA DE DADOS EM C# =====================================================================

*Comandos:
Console.WriteLine(valor);
Console.Write(valor);

*Controlando as casas decimais:
Console.WriteLine(saldo.toString("F2"));

*Imprimir um número decimal com ponto ao invés da vírgula:
 ________________________________________________________________________
| using System.Globalization;                                            |
|                                                                        |
| double saldo = 10.35784;                                               |
|                                                                        |
| Console.WriteLine(saldo.toString("F4"), CultureInfo.InvariantCulture); |
 ------------------------------------------------------------------------

*Placeholders
Console.WriteLine("{0} tem {1} anos e tem saldo igual a {2:F2}", nome, idade, saldo);
Console.WriteLine("{0} tem {1} anos e tem saldo igual a {2} reais.", nome, idade, saldo.toString("F2"), CultureInfo.InvariantCulture);

*Interpolação
Console.WriteLine($"{nome} tem {idade} anos e tem saldo igual a {saldo:F2} reais.");
Console.WriteLine($"{nome} tem {idade} anos e tem saldo igual a {saldo.toString("F2", CultureInfo.InvariantCulture)} reais.");

*Concatenação
Console.WriteLine(nome + " tem " + idade + " anos e tem saldo igual a " + saldo.toString("F2") + " reais.");
Console.WriteLine(nome + " tem " + idade + " anos e tem saldo igual a " + saldo.toString("F2", CultureInfo.InvariantCulture) + " reais.");

==================================================================== AULA 19 - OPERADORES ARITMÉTICOS ====================================================================

*Operadores:
+ - * / %
 ________________________________________
| NOTAS:                                 |
| 1) * / % tem precedência maior que + - |
| 2) Exemplos                            |
| 	3 + 4 * 2 --> Resultado 11       |
|	(3 + 4) * 2 --> Resultado 14     |
| 3) Pode-se usar parênteses à vontade   |
| 4)Exemplo com mod:                     |
|	17 % 3 --> Resultado: 2          |
 ----------------------------------------

*Divisão de números inteiros com resultado fracionário:
	int n4 = 10 / 8; 
=> resultado vai ser 1. Pois como há a divisão de dois números inteiros, a máquina entende que se pretende obter apenas a parte inteira do resultado. O correto seria usar o casting:
	double n4 = (double) 10 / 8;	ou	double n4 = 10.0 / 8;

*Declarando diversas variáveis de uma vez:
	double a = 1.0, b = -3.0, c = -4.0;

=================================================================== AULA 20 - OPERADORES DE ATRIBUIÇÃO ===================================================================

 ______________________________________
| Operador | Exemplo |   Significado   |
|--------------------------------------|
|     =    | a = 10; |   a RECEBE 10   |
|    +=    | a += 2; | a RECEBE a + 2; |
|    -=    | a -= 2; | a RECEBE a - 2; |
|    *=    | a *= 2; | a RECEBE a * 2; |
|    /=    | a /= 2; | a RECEBE a / 2; |
|    %=    | a %= 3; | a RECEBE a % 3; |
 --------------------------------------

*Atribuição em strings com o operador +=
	string x = "ABC";
	Console.WriteLine(x);
	x += "DEF";
	Console.WriteLine(x);
Obs: a atribuição também serve caso o segundo valor esteja armazenado em uma variável.

 _______________________________________
| Operador |    Exemplo   | Significado |
|    ++    | a++; ou ++a; | a = a + 1;  |
|    --    | a--; ou --a; | a = a - 1;  |
 ---------------------------------------

*a++
int x1 = 10;
int x2 = x1++; // Atribui o valor de x1 para a variável x2, e depois incrementa o valor da variável x1.

*++a
int x3 = 20;
int x4 = ++x3; // Incrementa o valor da variável x3, e depois atribui o valor de x3 para a variável x4.

================================================================ AULA 21 - CONVERSÃO IMPLÍCITA E CASTING =================================================================

*Conversão implícita entre tipos:
https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/implicit-numericconversions-table

	 _________________
	| float x = 4.5f; |
	| double y = x;   | => Operação possível, pois float tem 4bytes e double tem 8bytes. Sendo assim, a variável float, cabe dentro da variável double.
	 -----------------
	 _________________
	| double a = 5.1; |
	| float b = a;    | => Operação incorreta, pois uma variável double não cabe dentro de uma variável float, podendo haver perda de dados.
	 -----------------     Caso o programador tenha certeza da operação, pode ser feita a conversão utilizando CASTING.

	 ___________________________
	| int a = 5;                |
	| int b = 2;                | => A variável resultado terá valor 2, pois como é uma divisão de dois números inteiros, o compilador entende que o resultado
	| double resultado = a / b; |    da divisão deve ser um número inteiro, considerando apenas a parte inteira da divisão. Para garantir que o resultado seja double,
	 ---------------------------     e que as casas decimais não sejam descartadas, deve-se fazer uma conversão explícita (CASTING).

*Casting:
Conversão explícita entre tipos COMPATÍVEIS

	 _____________________
	| double a = 5.1;     |
	| float b = (float)a; | => Conversão explícita
	 ---------------------
	 _____________________
	| double a = 5.1;     |
	| float c = (int)a;   | => Conversão explícita. Nesse tipo de conversão, os valores depois da vírgula serão truncados.
	 ---------------------

============================================================== AULA 22 - ENTRADA DE DADOS EM C# (PARTE 1) ================================================================

* Console.ReadLine()
- Lê da entrada padrão até a quebra de linha;
- Retorna os dados lidos na forma de string;

* Split
Recorta uma string em vários pedaços conforme foi informado ao compilador.
	 _____________________________
	| "batata" "tomate" "abacaxi" | => O comando SPLIT é utilizado para "separar" nesse caso, as três palavras em variáveis diferentes, sendo que foram digitadas
	|   p1       p2        p3     |    na mesma linha no console.
	 -----------------------------
											 _______________________________________________
	string s = Console.ReadLine();							| string[] vet = Console.ReadLine().Split(' '); |
	string[] vet = s.Split(' ');							| string p1 = vet[0];                           |
	string p1 = vet[0];				=> SIMPLIFICANDO =>		| string p2 = vet[1];                           |
	string p2 = vet[1];								| string p3 = vet[2];                           |
	string p3 = vet[2];								 -----------------------------------------------

============================================================== AULA 23 - ENTRADA DE DADOS EM C# (PARTE 2) ================================================================

*Convertendo Console.ReadLine() para outros tipos de variáveis
Como o comando Console.ReadLine é usado somente para strings, deve-se converter para o tipo de dado desejado
	int n1 = int.Parse(Console.ReadLine());
	char ch = char.Parse(Console.ReadLine());
	double n2 = double.Parse(Console.ReadLine());  => ao converter para números decimais, deve-se atentar quanto à vírgula na saída do dado devido ao idioma do
							teclado, sendo necessário usar o comando CultureInfo.InvariantCulture

================================================================== AULA 25 - OPERADORES COMPARATIVOS =====================================================================

 ___________________________
| Operador |   Significado  |
|---------------------------|
|    >     |      maior     |
|    <     |      menor     |
|    >=    | maior ou igual |
|    <=    | menor ou igual |
|    ==    |      igual     |
|    !=    |    diferente   |
 ---------------------------

===================================================================== AULA 26 - OPERADORES LÓGICOS =======================================================================

 ________________________								 __________________ 	 ____________________       _____________
| Operador | Significado |	NOTAS:							| C1 | C2 | C1 E C2|	| C1 | C2 | C1 OU C2 |     | C1 | NÃO C1 |
|----------|-------------|	1) Precedência: ! > && > ||				|----|----|--------|	|----|----|----------|     |----|--------|
|    &&    |      E      |	2) Pode-se usar parênteses à vontade			|  F |  F |    F   |	|  F |  F |     F    |     |  F |    V   |
|    ||    |      OU     |	3) Exemplos:						|  F |  V |    F   |	|  F |  V |     V    |     |  V |    F   |
|    !     |     NÃO     |		2 > 3 || 4 != 5  --> Resultado: true		|  V |  F |    F   |	|  V |  F |     V    |      -------------
 ------------------------		!(2 > 3) && 4 != 5  --> Resultado: true		|  V |  V |    V   |	|  V |  V |     V    |
											 ------------------	 --------------------

=============================================================== AULA 27 - ESTRUTURA CONDICIONAL (IF-ELSE) ================================================================

*Estrutura Condicional Simples:			*Estrutura Condicional Composta				*Estrutura Condicional com Encadeamentos
	if (condicao) {					if (condicao) {					if (condicao 1){
	   comando 1					   comando 1					   comando 1
	   comando 2					   comando 2					   comando 2
	}						}						}
							else{						else if (condicao 2){
							   comando 3					   comando 3
							   comando 4					   comando 4
							}						}
													else if (condicao 3){
	 _____________________________________________							   comando 5
	| NOTA: se o bloco de comandos possuir apenas |							   comando 6
	|     um comando, as chaves são opcionais     |								}
	 ---------------------------------------------							else {
													   comando 7
													   comando 8
													}

=================================================================== AULA 28 - ESCOPO E INICIALIZAÇÃO =====================================================================

*Escopo de uma variável:
- É a região do programa onde a variável é válida, ou seja, onde ela pode ser referenciada
- Uma variável não pode ser usada se não for iniciada
- Quando se declara uma variável dentro de uma estrutura, a variável só irá existir durante a execução da estrutura. Quando a execução terminar, a variável será 
desalocada.
- Não se pode utilizar uma variável de um escopo menor, dentro de um escopo maior.

====================================================================== AULA 30 - FUNÇÕES (SINTAXE) =======================================================================

* Representam um processamento que possui significado:
	- Math.Srqt(double)
	- Console.WriteLine(string)

* Principais vantagens:
	- Modularização - dividir o programa em partes menores
	- Delegação - delegar o processamento para outro local
	- Reaproveitamento - chamar uma função ao invés de repetir todo o algoritmo

* Dados de entrada e saída
	- Funções podem receber dados de entrada (parâmetros ou argumentos)
	- Funções podem ou não retornar uma saída

* Em orientação a objetos, funções em classes, recebem o nome de "métodos"

================================================================= AULA 31 - DEBUGGING COM VISUAL STUDIO ==================================================================

*Debugging:
Execução passo-a-passo do algoritmo

*Teclas:
- F9 - Marcar/desmarcar breakpoints (ponto a partir de onde será executado o debug);
- F5 - Iniciar/continuar o debug;
- F10 - executar um passo (pula função);
- F11 - executar um passo (entra na função);
- SHIFT + F11 - sair do método em execução;
- SHIFT + F5 - interrompe o debug;

*Observações:
- Linha destacada em vermelhor indica existência de um breakpoint;
- Linha destacada em amarelo indica a próxima linha a ser executada;
- Aba 'Locals' no Visual Studio no modo debug, vai conter todas as variáveis do escopo local (escopo da função);
- Aba 'Watch' - expressões personalizadas;
- Aba 'Autos' - expressões "interessantes" detectadas pelo Visual Studio;
- Quando for usada a tecla F10 no modo debug, ao chegar em uma função, o debug irá "pular" a função e não irá entrar nela;

============================================================ AULA 32 - ESTRUTURA REPETITIVA ENQUANTO (WHILE) =============================================================
						 ____________________
* Estrutura "enquanto"				| REGRA:             |
	while (condição) {			|		     |
	   comando 1				| V: executa e volta |
	   comando 2				| F: pula fora       |
	}					 --------------------

=============================================================== AULA 34 - ESTRUTURA REPETITIVA PARA (FOR) ================================================================

 _________________	 ____________________	 __________________
| Executa somente |	| V: executa e volta |	| Executa toda vez |
| na primeira vez |	| F: pula fora       |	| depois de voltar |
 -----------------	 --------------------	 ------------------
		    \		  |		 /
		     \		  |		/
		for (início; condição; incremento){
   		   comando 1
   		   comando 2
		}

*Usada quando você conhece antecipadamente a quantidade de repetições;

========================================== AULA 39 - CRIANDO UMA CLASSE COM TRÊS ATRIBUTOS PARA REPRESENTAR MELHOR O TRIÂNGULO ===========================================

---Resolvendo o exercício da área de dois triângulos (aula anterior) usando orientação a objetos.----		Memória:
														 _____________________
*Discussão:													|   		      |
Triângulo é uma entidade com três atributos: a, b, c.								| 3.00   .00   5.00   |
Estamos usando três variáveis distintas para representar cada triângulo:					|   xA   xB     xC    |
														|   	              |
	double xA, xB, xC, yA, yB, yC;										|  7.50   4.50   4.02 |
														|   yA     yB     yC  |
Para melhorar isso, vamos utilizar uma CLASSE para representar um triângulo.                                     ---------------------

==========================CLASSE:

*É um tipo estruturado que pode conter (membros):
	-Atributos (dados / campos);
	-Métodos (funções / operações);

*A classe também pode prover muitos outros recursos, tais como:
	-Construtores;
	-Sobrecarga;
	-Encapsulamento;
	-Herança;
	-Polimorfismo;

*Exemplos:
	-Entidades: Produto, Cliente, Triângulo;
	-Serviços: ProdutoService, ClienteService, EmailService, StorageService
	-Controladores: ProdutoController, ClienteController
	-Utilitátios: Calculadora, Compactador
	-Outros: vies, repositórios, gerenciadores
 ____________________________________________________________________________________________________________________________________________________________________
| namespace Course																		     |
| {																				     |
|    class Triangulo																		     |
|    {																				     |
|       public double A;																	     |
|       public double B;																	     |
|       public double C;																	     |
|    }																				     |
| }																				     |
|																				     |
| double xA, xB, xC, yA, yB, yC;												Triangulo x, y;			     |
|   ____      ____     ____									____ ____ ____			x = new Triangulo;		     |
|  |    |    |    |   |    |				    				x -->  |    |    |    |			y = new Triangulo;		     |
|  |    |    |    |   |    |				    |\   			       |    |    |    |							     |
|   ----      ----     ----			____________|  \				---- ---- ----							     |
|    xA        xB       xC		       |		 \				  A    B    C							     |
|   ____      ____     ____		       |____________	 /				____ ____ ____			Agora, serão duas variáveis (x, y) e |
|  |    |    |    |   |    |			            |  /			y -->  |    |    |    |			elas serão do tipo Triangulo.  	     |
|  |    |    |    |   |    |				    |/				       |    |    |    |			(A classe também é um tipo de dado)  |
|   ----      ----     ----									---- ---- ----			Objeto composto que irá conter os 3  |
|    yA        yB       yC									  A    B    C			atributos A, B e C.		     |
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------

*INSTANCIAÇÃO				double areaX, areaY, P;
(alocação dinâmica de memória):		Triangulo x, y;			-->	new Triangulo();
 _______________________________________________________________________________________
|   				    MEMÓRIA						|
|    _____________________________		 ___________________________________	|
|   |		 STACK		  |		|		HEAP		    |   |         A parte da memória chamada Stack, é onde são armazenadas as
|   |    ____     ____     ____   |		|				    |   |         variáveis estáticas, conforme feita nas declarações.
|   |   |    |   |    |   |    |  |		|				    |   |	  Quando o tipo de uma variável é uma classe, deve ser instanciada
|   |   |    |   |    |   |    |  |		|				    |   |         a classe, e aí é criado na área Heap da memória, área dinâmica, o
|   |    ----     ----     ----   |		|				    |   |	  objeto composto contendo os atributos.
|   |   areaX     areaY      P    |		|				    |   |
|   |				  |		|   0x100358:                       |   |	  Na variável x (dentro da área Stack), vai conter o endereço do
|   |    ________     _________   |		|   _________ _________ _________   |   |	  objeto. Como se a variável x "apontasse" para o objeto.
|   |   |        |   |         |  |		|  |         |         |         |  |   |	  O x é uma referência para o objeto em si.
|   |   |        |   | 0x100358| -|-------------|->|         |         |         |  |   |
|   |    --------     ---------   |		|   --------- --------- ---------   |   |
|   |        x            Y       |		|        A         B         C      |   |	Classe: é a definição do tipo
|   |-----------------------------		 -----------------------------------    |	Objetos: são instâncias da classe
|										        |
 ---------------------------------------------------------------------------------------

======================================== AULA 41 - CRIANDO UM MÉTODO PARA OBTERMOS OS BENEFÍCIOS DE REAPROVEITAMENTO E DELEGAÇÃO =========================================

*Discussão:
Com o uso da CLASSE, agora nós temos uma variável composta do tipo "Triângulo" para representar cada triângulo:
	
	Triangulo x, y;
	x = new Triangulo();
	y = new Triangulo();

Agora, vamos melhorar nossa CLASSE, acrescentando um MÉTODO para calcular a área.
(No problema dos triângulos, há repetição de código no cálculo da área, além de um cálculo de área específico não deveria ficar no programa principal)

*Projeto da Classe (UML) - desenhar uma classe antes mesmo de programar.
 __________________________
|         Triangulo   <----|------------Nome da Classe
|--------------------------|
| - A : double             |
| - B : double        <----|------------Atributos da Classe
| - C : double             |
|--------------------------|
| + CalcularArea(): double |<-----------Métodos da Classe
 --------------------------

*Quais são os benefícios de se calcular a área de um triângulo por um meio de um MÉTODO dentro da CLASSE Triangulo?
	-Reaproveitamento de código: nós eliminamos o código repetido (cálculo das áreas dos triângulos x e y) no programa principal;
	-Delegação de responsabilidades: quem deve ser responsável por saber como calcular a área de um triângulo é o próprio triângulo. A lógica do cálculo da área não 		deve estar em outro lugar.

====================================================================== AULA 43 - OBJECT E ToString =======================================================================

*Toda classe em C# é uma subclasse da classe Object

*Object possui os seguintes métodos:
	-GetType - retorna o tipo do objeto;
	-Equals - compara se o objeto é igual ao outro;
	-GetHashCode - retorna um código hash do objeto;
	-ToString - converte o objeto para string;

================================================================= AULA 46 - MEMBROS ESTÁTICOS (PARTE 1) ==================================================================

Uma classe possui membros, que são atributos e/ou métodos.

* Também chamados membros de classe
- Em oposição a membros e instância.

* São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe.

* Aplicações comuns:
- Classes utilitárias; -- Math.Sqrt(double)
- Declaração de constantes;

* Uma classe que possui somente membros estáticos, pode ser uma classe estática também. Esta classe não poderá ser instanciada.

Exemplo:
 _______________________________________________________________
| Triangulo x, y;						|
| x = new Triangulo();						|	=> Não é uma operação estática. É uma operação de instância.
| y = new Triangulo();						|	Na operação estática sempre vai dar o mesmo resultado independente do objeto.
|								|
|       _____ _____ _____					|
| X -> | 3.0 | 4.0 | 5.0 |		x.Area()  => 6.0000	|
|	----- ----- -----					|
|	  a     b     c						|
|       _____ _____ ______					|
| y -> | 7.5 | 4.5 | 4.02 |		y.Area()  => 7.5638	|
|	----- ----- ------					|
|	  a     b     c						|
|---------------------------------------------------------------

* Não se pode chamar uma função que não é estática da mesma classe, dentro de uma função estática.

================================================================= AULA 47 - MEMBROS ESTÁTICOS (PARTE 2) ==================================================================

* SOLUÇÃO 2:
No exemplo da solução 2, é removido a palavra 'static' dos membros da classe, e acrescentada palavra 'public' permitindo assim ser acessada pela classe principal.
Também é necessário instanciar um objeto para a classe Calculadora.

Discussão:
 _______________________________________________________________
| * No problema dos triângulos, cada triângulo possui sua área  |	* Já no caso da Calculadora, os valores dos cálculos não mudam para calculadoras diferentes,
| * Area() é uma operação concernente ao objeto:		|	ou seja, são cálculos estáticos. O valor de PI é também estático.
| y = new Triangulo();						|	
|								|	Calculadora calc1 = new Calculadora();
|       _____ _____ _____					|	Calculadora calc2 = new Calculadora();
| X -> | 3.0 | 4.0 | 5.0 |		x.Area()  => 6.0000	|
|	----- ----- -----					|	calc1 --> Pi = 3.14 => calc1.Circunferencia(3.0);
|	  a     b     c						|	18.85
|       _____ _____ ______					|	calc2 --> Pi = 3.14 => calc2.Circunferencia(3.0);
| y -> | 7.5 | 4.5 | 4.02 |		y.Area()  => 7.5638	|	18.85
|	----- ----- ------					|
|	  a     b     c						|
|---------------------------------------------------------------

* SOLUÇÃO 3:
Não há a chamada aos métodos da classe Calculadora, através dos objetos. A chamada aos métodos ocorre diretamente pela classe.

========================================================================= AULA 51 - CONSTRUTORES =========================================================================

* É uma operação especial da classe, que executa no momento da instanciação do objeto.

* Uso comuns:
- Iniciar os valores dos atributos;
- Permitir ou obrigar que o objeta receba dados / dependências no momento de sua instanciação (injeção de dependência)

* Se um construtor customizado não for especificado, a classe disponibiliza o construtor padrão:
- Produto p = new Produto();

* É possível especificar mais de um construtor na mesma classe (sobrecarga)

Proposta de Melhoria:
Quando executamos o comando abaixo, instanciamos um produto "p" com seus atributos "vazios":

				MEMÓRIA:
				______ ______ _____
p = new Produto();	p -->  | null | 0.0  | 0   |
				------ ------ -----
				 Nome  Preço   Quantidade

Entretanto, faz sentido um produto que não tem nome? Faz sentido um produto que não tem preço?
Com o intuito de evitar a existência de produtos sem nome e sem preço é possível fazer com que seja "obrigatória" a iniciação desses valores?

========================================================================== AULA 52 - SOBRECARGA ==========================================================================

* É um recurso que uma classe possui de oferecer mais de uma operação com o mesmo nome, porém com diferentes listas de parâmetros;

* Proposta de melhoria:
- Vamos criar um construtor opcional, o qual recebe apenas o nome e preço do produto. A quantidade em estoque deste novo produto, por padrão, deverá então ser iniciada com o valor zero;
- NOTA: é possível também incluir um construtor padrão (sem parâmetros);

=========================================================== AULA 53 - SINTAXE ALTERNATIVA PARA INICIAR VALORES ===========================================================

Produto p1 = new Produto {
    Nome  = "TV",				exemplo 1 - sem parênteses
    Preco = 900.00,
    Quantidade = 0
};

Produto p2 = new Produto() {
    Nome  = "TV",				exemplo 2 - com parênteses
    Preco = 900.00,
    Quantidade = 0
};

Isso funciona mesmo se a classe não possuir construtores implementados.

*DICA: ao digitar o novo objeto e chegar nas chaves, se digitar CTRL + Espaço, o Visual Studio completa os atributos automaticamente.

========================================================================= AULA 54 - PALAVRA THIS =========================================================================

* È uma referência para o próprio objeto.

* Usos comuns:
- Diferenciar atributos de variáveis locais (Java);
- Referenciar outro construtor em um construtor;
- Passar o próprio objeto como argumento na chamada de um método ou construtor;

		Diferenciar atributos de variáveis locais:

Produto p = new Produto("TV", 1500.00);		public Produto(string Nome, double Preco){
						   this.Nome = Nome;
					==>	   this.Preco = Preco;
						   Quantidade = 0;
						}
 _______________________________________________________________________________________
|   				    MEMÓRIA						|
|    _____________________________		 ___________________________________	|
|   |		 STACK		  |		|		HEAP		    |   |         Se os atributos foram colocados com letra maiúscula, e os 
|   |   ______________________	  |		|				    |   |         parâmetros do construtor também foram colocados como letras
|   |  |(escopo do construtor)|	  |		|				    |   |	  maiúsculas, como saber o que é parâmetro, e o que é atributo?
|   |  |      ________	      |	  |		|				    |   |         
|   |  |     |  "TV"  |	      |   |		|				    |   |	  Nesse caso, deve-se usar a palavra 'this'
|   |  |      --------	      |	  |		|				    |   |
|   |  |        Nome	      |	  |		|   		                    |   |	  Sem a palavra 'this', o compilador vai priorizar a variável local,	  
|   |  |  		      |	  |		|   _________ _________ _________   |   |	  que no exemplo é o parâmetro que chegou.
|   |  |     _________	      |	  |		|  |         |         |         |  |   |	  
|   |  |    | 1500.00 |	      |p -|-------------|->|         |         |         |  |   |
|   |  |     ---------	      |	  |		|   --------- --------- ---------   |   |	 
|   |  |      Preco           |   |		|     Nome     Preco      Quantidade|   |
|   |	----------------------    |		|				    |   |
|    -----------------------------		 -----------------------------------    |	
|										        |
 ---------------------------------------------------------------------------------------

======================================================================== AULA 55 - ENCAPSULAMENTO ========================================================================

* É um princípio que consiste em esconder detalhes de implementação de um componente, expondo apenas operações seguras e que o mantenha em um estado consistente.
* Regra de ouro: o objeto deve sempre estar em um estado consistente, e a própria classe deve garantir isso.

* OPÇÃO 1: Implementação manual
- Todo atributo é definido como private
- Implementa-se métodos Get e Set para cada atributo, conforme regras de negócio
- Nota: não é usual na plataforma C#

* Um atributo private indica que ele não pode ser acessado por outra classe.
* Quando se trabalha com atributos privados, usa-se outra convenção para nomes:
	-exemplos: _nome (inicia com underline e a letra minúscula)

========================================================================== AULA 56 - PROPERTIES ==========================================================================

* São definições de métodos encapsulados, porém expondo uma sintaxe similar à de atributos e não de métodos.

• https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/properties
	- Uma propriedade é um membro que oferece um mecanismo flexível para ler, gravar ou calcular o valor de um campo em particular. As propriedades podem ser usadas 	como se fossem atributos públicos, mas na verdade elas são métodos especiais chamados "acessadores". Isso permite que os dados sejam acessados facilmente e ainda 	ajuda a promover a segurança e a flexibilidade dos métodos.

======================================================================= AULA 57 - AUTO PROPERTIES =======================================================================

* Propriedades autoimplementadas
- É uma forma simplificada de declarar propriedades que não necessitam lógicas particulares para as operações get e set.

public double Preco {get; private set; }

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties

DICA:
um atalho para não precisar digitar toda a linha é:
escrever prop  e pressionar TAB + TAB

==================================================== AULA 58 - ORDEM SUGERIDA PARA IMPLEMENTAÇÃO DE MEMBROS DA CLASSE ====================================================

Ordem Sugerida:
- Atributos privados;
- Propriedades automimplementadas;
- Construtores;
- Propriedades customizadas;
- Outros métodos da classe;

=================================================================== AULA 59 - MODIFICADORES DE ACESSO ===================================================================

• https://docs.microsoft.com/en-us/dotnet/csharp/languagereference/keywords/access-modifiers

* Membros:
 _____________________________________________________________________________________________________________________________________________
|                    | própria classe | subclasses do assembly | classes do assembly | sublcasses fora do assembly | classes fora do assembly |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
|       public       |        X       |            X           |          X          |              X              |             X            |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
| protected internal |        X       |            X           |          X          |              X              |                          |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
|      internal      |        X       |            X           |          X          |                             |                          |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
|      protected     |        X       |            X           |                     |              X              |                          |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
| private protected  |        X       |            X           |                     |                             |                          |
|--------------------|----------------|------------------------|---------------------|-----------------------------|--------------------------|
|       private      |        X       |                        |                     |                             |                          |
 -------------------------------------|------------------------|---------------------|-----------------------------|--------------------------|

* Classes:
- Acesso por qualquer classe
	public class Product
- Acesso somente dentro do assembly
	internal class Product
	class Product
- Acesso somente pela classe-mãe
	private class Product
	Nota: classe aninhada, por padrão, é private

================================================================ AULA 66 - TIPOS REFERÊNCIA E TIPOS VALOR ================================================================

* Classes são tipos referência:
Variáveis cujo tipo são classes não devem ser entendidas como caixas, mas sim "tentáculos" (ponteiros) para caixas.
					 _________________________________________
Product p1, p2;				|		MEMÓRIA	                  |
					|  _____________      __________________  |	Se for feito:
p1 = new Product("TV", 900.00, 0);	| |   STACK     |    |     HEAP         | |	
					| |  ________   |    |                  | |	p2 = p1;
					| | |0x100358|  |    | 0X100358:        | |
					| | |        |  |    |  ______________  | |	"p2 passa a apontar para onde p1 aponta"
					| |  --------   |    | | TV | 900 | 0 | | |
					| |     p1      |    | |    |     |   | | |
					| |	        |    |  --------------  | |
					|  -------------      ------------------  |
					 ----------------------------------------- 

* Valor "null" 
Tipos referência aceitam o valor "null", que indica que a variável aponta pra ninguém.

p2 = null;

* Structs são tipos valor
A linguagem C# possui também tipos valor, que são os "structs". Structs são CAIXAS e não ponteiros. Tipos valor são os tipos básicos (int, float, bool etc.). Também entram nesse tipo o DateTime, TimeSpan.
					 _________________________________________
double x, y;				|		MEMÓRIA	                  |
					|  _____________      __________________  |	Se for feito:
x = 10                 			| |   STACK     |    |     HEAP         | |	
					| |  ________   |    |                  | |	y = x;
					| | |   10   |  |    |                  | |
					| | |        |  |    |                  | |	"y recebe uma cópia de x"
					| |  --------   |    |                  | |
					| |     x       |    |                  | |
					| |	        |    |                  | |
					|  -------------      ------------------  |
					 ----------------------------------------- 

* É possível criar seus próprios structs. O Struct é parecido com a classe, mas com algumas diferenças.
namespace Course {
   struct Point {
   
	public double X, Y;
   
   	public override string ToString(){
   	   return "(" + X + "," + Y + ")";
	}
   }
}

* Valores Padrão
- Quando alocamos (new) qualquer tipo estruturado (classe, struct, array), são atribuídos valores padrão aos seus elementos.
	- números: 0
	- bool: False
	- char: caractere código 0
	- objeto: null

- Lembrando: uma variável apenas declarada, mas não instanciada, inicia em estado "não atribuída", e o próprio compilador não permite que ela seja acessada.

* Tipos Referência vs Tipos Valor
 _________________________________________________________________________________________________________________________________________________________________________
|					CLASSE					      |					STRUCT						  |
|_____________________________________________________________________________________|___________________________________________________________________________________|
|Vantagem: usufrui de todos os recursos OO					      |Vantagem: é mais simples e mais performático					  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Variáveis são ponteiros							      |Variáveis são caixas								  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Objetos precisam ser instanciados usando new, ou apontar para um objeto já existente |Não é preciso instanciar usando new, mas é possível				  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Aceita valor null								      |Não aceita valor null								  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Suporte a herança								      |não tem suporte a herança (mas pode implementar interfaces)			  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Y = X; "Y passa a apontar para onde X aponta"					      |Y = X; "Y recebe uma cópia de X"							  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Objetos instanciados no heap							      |Objetos instanciados no stack							  |
|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Objetos não utilizados são desalocados em um momento próximo pelo garbage collector  |"Objetos" são desalocados imediatamente quando seu escopo de execução é finalizado |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================== AULA 67 - DESALOCAÇÃO DE MEMÓRIA - GARBAGE COLLECTOR E ESCOPO LOCAL ==================================================

* Garbage Collecctor
- É um processo que automatiza o gerenciamento de memória de um programa em execução.
- O Garbage Collector monitora os objetos alocados dinamicamente pelo programa (no heap), desalocando aqueles que não estão mais sendo utilizados.

* Desalocação por Garbage Collector
					 _________________________________________
Product p1, p2;				|		MEMÓRIA	                  |
					|  _____________      __________________  |	Se for feito:
p1 = new Product("TV", 900.00, 0);	| |   STACK     |    |     HEAP         | |	
					| |             |    |  ______________  | |	p1 = p2;
p2 = new Product("Mouse", 30.00, 0	| |         	|    | | TV | 900 | 0 | | |
					| | 	    p1	------>|    |     |   | | |	"p1 passa a apontar para onde p2 aponta"
					| |  		|    |  --------------	| |
					| |             |    |  ______________  | |	
					| |         	|    | |Mouse | 30 | 0| | |	Será desalocado no heap o objeto ("TV", 900.00, 0) pelo garbage collector
					| | 	    p2	------>|      |    |  | | |    
					| |	        |    |  --------------  | |
					|  -------------      ------------------  |
					 ----------------------------------------- 

* Desalocação por escopo
					 __________________________________________
void method1() {			|		      MEMÓRIA              |
    int x - 10;				|  ___________________      _____________  |	O escopo method1 tem seu escopo, e dentro dele, tem a variável x valendo 10.
    if (x > 0) {			| |   STACK           |    |     HEAP    | |	
    	int y = 20;			| |  _______________  |    |             | |	Quando a execução chegar dentro do comando if,
    }					| | | method1 scope | |    |             | |	vai ser criada uma variável y, valendo 20.
}					| | |  ______       | |    |             | |	Esse y, vai estar dentro do escopo do if, que por sua vez, vai estar
					| | | |	 10  |	    | |    | 		 | |	dentro do escopo do method1
					| | |  ------       | |    |  		 | |	
					| | |    x          | |	   |		 | |	Quando a execução sair do comando if, automaticamente a variável y,
					| | |  ___________  | |	   |   		 | |    será desalocada.
					| | | |  if scope | | |    |		 | |
					| | | |   ______  | | |    |		 | |
					| | | |  |  20  | | | |    |		 | |
					| | | |   ------  | | |    |		 | |
					| | | |      y    | | |    |		 | |
					| | |  -----------  | |    |		 | |
					| | |---------------| |    |		 | |
					|  -------------------      -------------  |
					 ------------------------------------------ 

* Resumo:
- Objetos alocados dinamicamente, quando não possuem mais referência para eles, serão desalocados pelo Garbage Collector.
- Variáveis locais são desalocadas imediatamente assim que seu escopo local sai de execução.

=========================================================================== AULA 68 - NULLABLE ===========================================================================

- É um recurso do C# para que dados de tipo valor (struct) possam receber o valor null
- Uso comum:
	- Campos de banco de dados que podem valer nulo (data de nascimento, algum valor numérico, etc.)
	- Dados e parâmetros opcionais.

* Demo:
double x = null; /// Erro
Nullable<double> x = null; // Correto, mas pode ser simplificado
double? x = null;

* Métodos
	- GetValueOrDefault
	- HasValue
	- Value (lança uma exceção se não houver valor)

* Operador de coalescência nula
• https://docs.microsoft.com/en-us/dotnet/csharp/languagereference/operators/null-conditional-operator
	double? x = null;
	double y = x ?? 0.0;
	- Como a variável y não é nula, na atribuição de y, caso o valor de x seja diferente de nulo, é atribuído o valor de x na variável y. Se o valor de x for nulo, é 	atribuído o valor que está no lado direito (no exemplo, será atribuído 0.0).

====================================================================== AULA 69 - VETORES (PARTE 1) ======================================================================

* Vetores
- Em programação, "vetor" é o nome dado a arranjos unidimensionais.
- Arranjo é um estrutura de dados:
	- Homogênea (dados do mesmo tipo);
	- Ordenada (elementos acessados por meio de posições);
	- Alocada de uma vez só, em um bloco contíguo de memória;

* Vantagens:
	- Acesso imediato aos elementos pela sua posição;
* Desvantagens:
	- Tamanho fixo;
	- Dificuldade para se realizar inserções e deleções;

====================================================================== AULA 70 - VETORES (PARTE 2) ======================================================================

Quando é criado um vetor de classes, antes de atribuir valores aos atributos dos objetos, é necessário instanciar cada objeto.

=============================================================== AULA 72 - MODIFICADOR DE PARÂMETROS PARAMS ===============================================================

* Modificador params
Suponha que se queira uma calculadora para calcular a soma de uma quantidade variável de valores. Solução ruim usando sobrecarga:
	namespace Course {
		class Calculator {
			public static int Sum(int n1, int n2)
			{
				return n1 + n2;
			}

			public static int Sum(int n1, int n2, int n3)
			{
				return n1 + n2 + n3;
			}

			public static int Sum(int n1,  int n2, int n3, int n4)
			{
				return n1 + n2 + n3 + n4;
			}
		}
	}

* Solução p/ classe Calculator / Program:
namespace Course								using System;
{									
    class Calculator								namespace Course
    {										{
        public static int Sum(params int[] numbers)				    class Program
        {									    {
            int sum = 0;							        static void Main(string[] args)
            for (int i = 0; i < numbers.Length; i++)				        {
            {									            int s1 = Calculator.Sum(2, 3);
                sum += numbers[i];							    int s2 = Calculator.Sum(2, 4, 3);
            }										    int result = Calculator.Sum(10, 20, 30, 40);
            return sum;						
        }										    Console.WriteLine(s1);
    }											    Console.WriteLine(s2);
}											    Console.WriteLine(result);
											}
										    }
										}

============================================================== AULA 73 - MODIFICADORES DE PARÂMETROS REF E OUT ===========================================================

* Modificador ref
Suponha que se queira uma calculadora com uma operação para triplicar o valor de um número passado como parâmetro. A seguir uma solução que não funciona:
 _______________________________________________________________________________________________________________________________________________________________
|	class Calculator {					|		class Program {									|
|								|		    static void Main (string[] args) {						|
|	    public static void Triple(int x) {			|			int a = 10;								|
|		x = x * 3;					|			Calculator.Triple(a);							|
|	    }							|			Console.WriteLine(a);							|
|	}							|		    }										|
|								|		}										|
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------

EXPLICAÇÃO:
A execução do programa vai para a função Triple da classe Calculator, e cria um escopo provisório para a função Triple com o parâmetro x valendo 10. O valor de x é calculado dentro do escopo da função Triple. Quando a função terminar de executar, o programa vai voltar para a função principal, e o valor de x não será alterado.
Para criar uma função que receba um parâmetro e que seja capaz de alterar esse valor, deve-se incluir a palavra "ref", tanto na chamada da função, quanto na declaração:
 _______________________________________________________________________________________________________________________________________________________________
|	    public static void Triple(ref int x) {		|			int a = 10;								|
|		x = x * 3;					|			Calculator.Triple(ref a);						|
|	    }							|			Console.WriteLine(a);							|
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
Fazendo isso, não é passado um valor, e sim uma referência da variável original.

* Modificador out
Similar ao modificador ref (faz o parâmetro ser uma referência para a variável original), mas não exige que a variável original seja iniciada.

* Considerações sobre ref e out:
- Diferença:
	- A variável passada como parâmetro ref DEVE ter sido iniciada.
	- A variável passada como parâmetro out não precisa ter sido iniciada.

- Conclusão: ambos são muito similares, mas ref é uma forma de fazer o compilador obrigar o usuário a iniciar a variável.

- Nota: ambos são considerados "code smells" (design ruim) e devem ser evitados.

======================================================================== AULA 74 - BOXING E UNBOXING =====================================================================

* Boxing
É o processo de conversão de um objeto do tipo valor para um objeto tipo referência compatível:
	int x = 20;
	Object obj = x;

é criada dentro da área Stack uma variável com valor 20. O tipo Object (é do tipo referência, é uma classe) cria uma referência para um novo objeto instanciado na área Heap da memória. Apesar de ser permitido, é uma operação que tem um custo de processamento.

* Unboxing
É o processo de conversão de um objeto tipo referência para um objeto tipo valor compatível:
	int x = 20;
	Object obj = x;
	int y = (int) obj;

É criada uma variável na área Stack da memória recebendo o valor que foi instanciado na área Heap. Nesse exemplo, foi necessário fazer um casting.

================================================================ AULA 75 - SINTAXE OPCIONAL: LAÇO FOREACH ================================================================

Sintaxe opcional e simplificada para percorrer coleções.
Leitura: "para cada objeto 'obj' contido em vect, faça:"
	- 'obj' --> é um apelido (alias)

==================================================================== AULA 76 - LISTAS (LIST) - PARTE 1 ===================================================================

• Lista é uma estrutura de dados:
	• Homogênea (dados do mesmo tipo)
	• Ordenada (elementos acessados por meio de posições)
	• Inicia vazia, e seus elementos são alocados sob demanda
	• Cada elemento ocupa um "nó" (ou nodo) da lista

• Classe: List
• Namespace: System.Collections.Generic

• Vantagens:
	• Tamanho variável
	• Facilidade para se realizar inserções e deleções
• Desvantagens:
	• Acesso sequencial aos elementos *

==================================================================== AULA 77 - LISTAS (LIST) - PARTE 2 ===================================================================

• Inserir elemento na lista: Add, Insert
• Tamanho da lista: Count
• Encontrar primeiro ou último elementos da lista que satisfaça um predicado: list.Find, list.FindLast
• Encontrar primeira ou última posição de elemento da lista que satisfaça um predicado: list.FindIndex, list.FindLastIndex
• Filtrar a lista com base em um predicado: list.FindAll
• Remover elementos da lista: Remove, RemoveAll, RemoveAt, RemoveRange

=========================================================================== AULA 79 - MATRIZES ===========================================================================

• Em programação, "matriz" é o nome dado a arranjos bidimensionais

• Arranjo é uma estrutura de dados:
	• Homogênea (dados do mesmo tipo)
	• Ordenada (elementos acessados por meio de posições)
	• Alocada de uma vez só, em um bloco contíguo de memória

• Vantagens:
	• Acesso imediato aos elementos pela sua posição
• Desvantagens:
	• Tamanho fixo
	• Dificuldade para se realizar inserções e deleções

=============================================================== AULA 85 - INFERÊNCIA DE TIPOS: PALAVRA VAR ===============================================================

	var x = 10;
A variável x vale 10, e o tipo dela será inferido conforme ela for incializada.

Observação: o uso da palavra 'var' é uma comodidade para o programador, porém, o uso desordenado pode causar falhas, como por exemplo, uma variável inteira declarada como var, pode receber uma string que o compilador não irá rejeitar.

=============================================================== AULA 86 - SINTAXE ALTERNATIVA: SWITCH-CASE ===============================================================

Estrutura opcional a vários if-else encadeados, quando a condição envolve o teste do valor de uma variável.

====================================================== AULA 87 - SINTAXE ALTERNATIVA: EXPRESSÃO CONDICIONAL TERNÁRIA =====================================================

Estrutura opcional ao if-else quando se deseja decidir um VALOR com base em uma condição

* Sintaxe:
	(condição) ? valor_se_verdadeiro : valor_se_falso

============================================================= AULA 89 - DATETIME - REPRESENTANDO DATA E HORA =============================================================

* Representa um INSTANTE
* É um tipo valor (struct)

* Representação interna:
	- Um objeto DateTime internamente armazena:
		* O número de "ticks" (100 nanosegundos) desde a meia noite do dia 1 de janeiro do ano 1 da era comum.

	DateTime d1 = DateTime.Now;
	Console.WriteLine(d1);
	Console.WriteLine(d1.Ticks);

* Instanciação:
-Construtores:
	- DateTime(ano, mes dia);
	- DateTime(ano, mes dia, hora, minuto, segundo);
	- DateTime(ano, mes dia, hora, minuto, segundo, milisegundo);
-Builders:
	- DateTime.Now;
	- DateTime.UtcNow;
	- DateTime.Today;
	- DateTime.Parse(string);
	- DateTime.ParseExact(string, string);

=============================================================== AULA 90 - TIMESPAN - REPRESENTANDO DURAÇÕES ==============================================================

* Representa uma DURAÇÃO
* É um tipo valor (struct)

* Representação interna:
	- Um objeto TimeSpan internamente armazena uma duração na forma de "ticks" (100 nanosegundos).

	TimeSpan t1 = new TimeSpan(0, 1, 30);
	Console.WriteLine(t1);
	Console.WriteLine(ti.Ticks);